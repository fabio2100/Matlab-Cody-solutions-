function [y1,xf1,xf2] = pruebatimesteeps(x1,x2,xi1,xi2)
%MYNEURALNETWORKFUNCTION neural network simulation function.
%
% Generated by Neural Network Toolbox function genFunction, 30-Mar-2019 19:49:28.
%
% [y1,xf1,xf2] = myNeuralNetworkFunction(x1,x2,xi1,xi2) takes these arguments:
%   x1 = 1xTS matrix, input #1
%   x2 = 1xTS matrix, input #2
%   xi1 = 1x2 matrix, initial 2 delay states for input #1.
%   xi2 = 1x2 matrix, initial 2 delay states for input #2.
% and returns:
%   y1 = 1xTS matrix, output #1
%   xf1 = 1x2 matrix, final 2 delay states for input #1.
%   xf2 = 1x2 matrix, final 2 delay states for input #2.
% where TS is the number of timesteps.

% ===== NEURAL NETWORK CONSTANTS =====

% Input 1
x1_step1_xoffset = 1;
x1_step1_gain = 0.0002000200020002;
x1_step1_ymin = -1;

% Input 2
x2_step1_xoffset = 0;
x2_step1_gain = 0.217147240951626;
x2_step1_ymin = -1;

% Layer 1
b1 = [2.4367007058060524;-1.6199740496661292;1.4279007667565089;-0.74883115133973444;0.39216094628554704;-0.37454718407531401;-0.38922448316381253;1.3629513480227731;-1.9358636507330229;-2.7538899263199821];
IW1_1 = [-0.9028179664444862 1.2242108061734873;2.0697807794175307 0.56001081580022694;-1.612207175378124 0.37603890355153596;0.72407562970994488 0.68702849523250198;-0.60997745772435952 -0.95381513387669925;-1.5248650749060306 1.4566785821662565;-1.6283094511769816 1.5917780697603563;0.38264909075710851 -0.68502569040649541;-0.20889734583948516 0.56109610576333935;-0.4337019447183505 -1.6503820786080399];
IW1_2 = [-1.4744857075239506 1.3083503868005539;0.48755308610867559 -0.95972897180733407;1.6380331960028496 -0.28965349705801774;1.3248093346326446 -1.02795627737381;-1.8090621109882297 0.7207903952828616;0.60681704743465037 -1.0603369588686236;-0.17464458769325747 0.96463371338186632;-1.9980825142615564 1.0963038421982174;-1.3220735975163898 2.0254753420831038;-1.4211503616568804 0.029538884279344365];

% Layer 2
b2 = 0.89313711269842189;
LW2_1 = [-0.89310326457508438 -0.015072228494454682 0.71328454270054831 -0.084016054715025268 0.02486365895761394 0.17434714028687415 0.92007682245978761 -0.8142464514393406 -0.09066740557773742 -0.30165115281160521];

% Output 1
y1_step1_ymin = -1;
y1_step1_gain = 0.217147240951626;
y1_step1_xoffset = 0;

% ===== SIMULATION ========

% Dimensions
TS = size(x1,2); % timesteps

% Input 1 Delay States
xd1 = mapminmax_apply(xi1,x1_step1_gain,x1_step1_xoffset,x1_step1_ymin);
xd1 = [xd1 zeros(1,1)];

% Input 2 Delay States
xd2 = mapminmax_apply(xi2,x2_step1_gain,x2_step1_xoffset,x2_step1_ymin);
xd2 = [xd2 zeros(1,1)];

% Allocate Outputs
y1 = zeros(1,TS);

% Time loop
for ts=1:TS
    
    % Rotating delay state position
    xdts = mod(ts+1,3)+1;
    
    % Input 1
    xd1(:,xdts) = mapminmax_apply(x1(:,ts),x1_step1_gain,x1_step1_xoffset,x1_step1_ymin);
    
    % Input 2
    xd2(:,xdts) = mapminmax_apply(x2(:,ts),x2_step1_gain,x2_step1_xoffset,x2_step1_ymin);
    
    % Layer 1
    tapdelay1 = reshape(xd1(:,mod(xdts-[1 2]-1,3)+1),2,1);
    tapdelay2 = reshape(xd2(:,mod(xdts-[1 2]-1,3)+1),2,1);
    a1 = tansig_apply(b1 + IW1_1*tapdelay1 + IW1_2*tapdelay2);
    
    % Layer 2
    a2 = b2 + LW2_1*a1;
    
    % Output 1
    y1(:,ts) = mapminmax_reverse(a2,y1_step1_gain,y1_step1_xoffset,y1_step1_ymin);
end

% Final delay states
finalxts = TS+(1: 2);
xits = finalxts(finalxts<=2);
xts = finalxts(finalxts>2)-2;
xf1 = [xi1(:,xits) x1(:,xts)];
xf2 = [xi2(:,xits) x2(:,xts)];
end

% ===== MODULE FUNCTIONS ========

% Map Minimum and Maximum Input Processing Function
function y = mapminmax_apply(x,settings_gain,settings_xoffset,settings_ymin)
y = bsxfun(@minus,x,settings_xoffset);
y = bsxfun(@times,y,settings_gain);
y = bsxfun(@plus,y,settings_ymin);
end

% Sigmoid Symmetric Transfer Function
function a = tansig_apply(n)
a = 2 ./ (1 + exp(-2*n)) - 1;
end

% Map Minimum and Maximum Output Reverse-Processing Function
function x = mapminmax_reverse(y,settings_gain,settings_xoffset,settings_ymin)
x = bsxfun(@minus,y,settings_ymin);
x = bsxfun(@rdivide,x,settings_gain);
x = bsxfun(@plus,x,settings_xoffset);
end
